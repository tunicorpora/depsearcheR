---
title: "depsearcheR -- basic usage"
author: "Juho HÃ¤rme"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{depsearcheR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


The DepsearcheR package is a simple utility made for the purpose of using R for
corpus analyses involving the utilization of dependency annotations represented
in some version of the CoNLL format (cf. e.g [here](https://stackoverflow.com/questions/27416164/what-is-conll-data-format)).

## Basic idea
 

Assume that you have parsed a file like the one provided in the `inst/extdata`
folder of this package (the Finnish wikipedia article for sparrow):

```{r}

library(depsearcheR)
library(readr)
mytext <- readr::read_file(
                           system.file("extdata", 
                                       "varpunen_wikipedia.txt",
                                       package="depsearcheR")
                           )

cat(substr(mytext,1,300))


```

The text has been parsed with [the Finnish dependency parser developed at the
university of Turku](http://turkunlp.github.io/Finnish-dep-parser/) and this
output file is also included in `inst/extdata`. Note that 
the format here is the so called universal dependencies format.
This is what the conll formatted file looks like:


    1	Varpunen	varpunen	NOUN	_	Case=Nom|Number=Sing	8	nsubj:cop	_	_
    2	(	(	PUNCT	_	_	4	punct	_	_
    3	Passer	Passer	PROPN	_	Case=Nom|Number=Sing	4	compound:nn	_	_
    4	domesticus	domesticus	NOUN	_	Case=Nom|Number=Sing	1	appos	_	_
    5	)	)	PUNCT	_	_	4	punct	_	_
    6	on	olla	VERB	_	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin|Voice=Act	8	cop	_	_
    7	yleinen	yleinen	ADJ	_	Case=Nom|Degree=Pos|Number=Sing	8	amod	_	_
    8	lintulaji	lintu#laji	NOUN	_	Case=Nom|Number=Sing	0	root	_	_
    9	suuressa	suuri	ADJ	_	Case=Ine|Degree=Pos|Number=Sing	10	amod	_	_
    10	osassa	osa	NOUN	_	Case=Ine|Number=Sing	8	nmod	_	_
    11	Eurooppaa	Eurooppa	PROPN	_	Case=Par|Number=Sing	10	nmod	_	_
    12	ja	ja	CONJ	_	_	11	cc	_	_
    13	Aasiaa	Aasia	PROPN	_	Case=Par|Number=Sing	11	conj	_	_
    14	.	.	PUNCT	_	_	8	punct	_	_

    1	Carolus	Carolus	PROPN	_	Case=Nom|Number=Sing	2	name	_	_
    2	Linnaeus	Linnaeus	PROPN	_	Case=Nom|Number=Sing	3	nsubj	_	_
    3	antoi	antaa	VERB	_	Mood=Ind|Number=Sing|Person=3|Tense=Past|VerbForm=Fin|Voice=Act	0	root	_	_
    4	varpuselle	varpunen	NOUN	_	Case=All|Number=Sing	3	nmod	_	_
    5	aluksi	aluksi	ADV	_	_	3	advmod	_	_
    6	nimen	nimi	NOUN	_	Case=Gen|Number=Sing	7	nmod:poss	_	_
    7	Fringilla	Fringilla	NOUN	_	Case=Ade|Number=Plur	3	nmod	_	_
    8	domestica	domestica	X	_	Foreign=Foreign	3	dobj	_	_
    9	.	.	PUNCT	_	_	3	punct	_	_


Now, let's imagine we have a data set consisting of all the sentences of the Finnish
wikipedia article mentioned above.

```{r}


library(dplyr)
library(readr)
sentences <- readr::read_file(
                           system.file("extdata", 
                                       "varpunen.conll",
                                       package="depsearcheR")
                           ) %>% 
        strsplit("\n\n")  %>% 
        unlist



```


First, let's assume that we want to get all the sentences including
one or more cases in which a noun is governed by a verb.

TODO: first make a reference data frame with all data as tabbed?
TODO: function to list possible columns and values

```{r}


#'  Makes a tibble of the raw conll string provided. Assumes one sentence.
#' 
#' @param concordance the raw string representing a sentence
#' @param conll_cols the structure of the conll (names of columns)
#' 
#' @export

ConcAsTibble <- function(concordance, 
                         conll_cols=c("tokenid","token","lemma","pos","pos2","feat","head","dep","null1","null2")){
    tab <- read.csv(text=concordance,sep="\t",row.names=NULL)  
    colnames(tab) <- conll_cols
    return (as_tibble(tab))
}

#' Filters a tibble representing a sentence and returns matches
#'
#' @param tab a conll represented sentence as a tibble
#' @param column_name e.g. POS, lemma
#' @param column_val what the value of the column should be, e.g N, igrat'
#' @param use_regex if false, exact matches will be searched, if true, regexes
#'
#' @return a filtered tibble
#'
#' @export

FilterConllRows <- function(tab, column_name, column_val, use_regex=F) {
    #Determine whether or not to use regex
    if(use_regex) {
        indices <- which(grepl(column_val,tab[[column_name]]))
    }
    else if (length(column_val) > 1) {
        indices <- which(tab[[column_name]] %in% column_val)
    }
    else {
        indices <- which(tab[[column_name]] == column_val)
    }

    return (tab[indices, ])
}

#' Checks if a sentence contains a case where a is governed by b
#'
#' @param headw c(column_name, column_value, [as_regex=T/F]) 
#' @param depw c(column_name, column_value, [as_regex=T/F])
#' @param sent the sentence to look in
#'
#' @export

ContainsDepRel <- function(depw, headw, sent){
    matched <- 0
    tab <- ConcAsTibble(sent)
    heads <- FilterConllRows(tab, headw[1], headw[2], 
                             ifelse(length(headw)>2, headw[3], F))
    deps <- FilterConllRows(tab, depw[1], depw[2], 
                             ifelse(length(depw)>2, depw[3], F))

    if(nrow(heads) > 0 & nrow(deps) > 0) {
        governed <- FilterConllRows(deps, "head", heads %>% pull(tokenid), F)
        if(nrow(governed) > 0) {
            return ( TRUE )
        }
    }
    return ( FALSE )
}

ContainsDepRel(depw=c("pos","ADJ"),
             headw=c("pos","NOUN"),
             sentences[1]
             )

ConcAsTibble(sentences[1])

```



```{r}

#1. find a finite verb

```



